# -*- coding: utf-8 -*-
"""XAML_to_SVG_transformer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XG75F3LuglH8NwHgBwdrqJwXBXVcekc4
"""

# Retry building the centered black SVG set and packaging it.

import os, re, zipfile

out_dir = "xaml_to_svg_shapes_black_centered"
os.makedirs(out_dir, exist_ok=True)

def wrap_svg(content, viewBox="0 0 400 400", extra_attrs=""):
    return f'''<svg xmlns="http://www.w3.org/2000/svg" viewBox="{viewBox}" {extra_attrs}>\n{content}\n</svg>\n'''

shapes = {}

# Define shapes
shapes["circle.svg"] = wrap_svg('<circle cx="200" cy="200" r="200" fill="currentColor" />')
shapes["equilateral_triangle.svg"] = wrap_svg('<path d="M200,0 L400,347.5 0,347.5 Z" fill="currentColor" transform="translate(0,26.25)"/>')
shapes["rectangle.svg"] = wrap_svg('<rect x="0" y="0" width="300" height="400" fill="currentColor" />')

star_path = ("M209.865497076023,0 L259.245614035088,153.086419753086 422.2,153.086419753086 "
             "291.342690058479,246.913580246914 340.722807017544,400 209.865497076023,306.172839506173 "
             "81.4771929824561,400 130.85730994152,246.913580246914 0,153.086419753086 "
             "160.485380116959,153.086419753086 209.865497076023,0 Z")
sx = 400.0/422.2
shapes["star_5_point.svg"] = wrap_svg(f'<path d="{star_path}" fill="currentColor" transform="translate(0,10) scale({sx},1)"/>')

crescent_path = ("M200,400 C92.3076923076923,400 0,312.820512820513 0,200 "
                 "0,92.3076923076923 92.3076923076923,0 200,0 "
                 "143.589743589744,51.2820512820513 107.692307692308,123.076923076923 107.692307692308,200 "
                 "107.692307692308,282.051282051282 143.589743589744,353.846153846154 200,400 Z")
shapes["crescent.svg"] = wrap_svg(f'<path d="{crescent_path}" fill="currentColor" />')

diamond_path = ("M129.4,0 L196.060606060606,101.960784313725 258.8,200 "
                "196.060606060606,301.960784313725 129.4,400 66.6606060606061,301.960784313725 "
                "0,200 66.6606060606061,101.960784313725 129.4,0 Z")
shapes["diamond.svg"] = wrap_svg(f'<path d="{diamond_path}" fill="currentColor" />')

penta_path = ("M210.65,0 L314.791573033708,75.7396449704142 421.3,153.846153846154 "
              "381.063483146067,276.923076923077 340.826966292135,400 210.65,400 80.4730337078652,400 "
              "40.2365168539326,276.923076923077 0,153.846153846154 104.141573033708,75.7396449704142 210.65,0 Z")
sx_p = 400.0/421.3
shapes["pentahedron.svg"] = wrap_svg(f'<path d="{penta_path}" fill="currentColor" transform="translate(0,10) scale({sx_p},1)"/>')

flash_path = ("M88.4290909090909,0 L21.0545454545455,160 67.3745454545455,160 "
              "0,277.894736842105 46.32,277.894736842105 0,400 138.96,235.789473684211 "
              "101.061818181818,235.789473684211 185.28,117.894736842105 143.170909090909,117.894736842105 "
              "231.6,0 88.4290909090909,0 Z")
tx = (400.0-231.6)/2.0
shapes["flash.svg"] = wrap_svg(f'<path d="{flash_path}" fill="currentColor" transform="translate({tx},0)"/>' )

octa_path = ("M281.212121212121,0 L341.818181818182,58.1818181818182 400,116.363636363636 400,198.787878787879 "
             "400,281.212121212121 341.818181818182,341.818181818182 281.212121212121,400 198.787878787879,400 "
             "116.363636363636,400 58.1818181818182,341.818181818182 0,281.212121212121 0,198.787878787879 "
             "0,116.363636363636 58.1818181818182,58.1818181818182 116.363636363636,0 198.787878787879,0 281.212121212121,0 Z")
shapes["octahedron.svg"] = wrap_svg(f'<path d="{octa_path}" fill="currentColor" />')

twelve_star_path = ("M198.802395209581,0 L237.125748502994,62.2754491017964 299.40119760479,26.3473053892216 "
                    "299.40119760479,100.59880239521 373.652694610778,100.59880239521 335.329341317365,162.874251497006 "
                    "400,198.802395209581 335.329341317365,237.125748502994 373.652694610778,299.40119760479 "
                    "299.40119760479,299.40119760479 299.40119760479,373.652694610778 237.125748502994,335.329341317365 "
                    "198.802395209581,400 162.874251497006,335.329341317365 100.59880239521,373.652694610778 "
                    "100.59880239521,299.40119760479 26.3473053892216,299.40119760479 62.2754491017964,237.125748502994 "
                    "0,198.802395209581 62.2754491017964,162.874251497006 26.3473053892216,100.59880239521 "
                    "100.59880239521,100.59880239521 100.59880239521,26.3473053892216 162.874251497006,62.2754491017964 "
                    "198.802395209581,0 Z")
shapes["star_12_point.svg"] = wrap_svg(f'<path d="{twelve_star_path}" fill="currentColor" />')

cross_solid_path = ("M132.544378698225,132.544378698225 L132.544378698225,0 267.455621301775,0 "
                    "267.455621301775,132.544378698225 400,132.544378698225 400,267.455621301775 "
                    "267.455621301775,267.455621301775 267.455621301775,400 132.544378698225,400 "
                    "132.544378698225,267.455621301775 0,267.455621301775 0,132.544378698225 132.544378698225,132.544378698225 Z")
shapes["cross_solid.svg"] = wrap_svg(f'<path d="{cross_solid_path}" fill="currentColor" />')

trapez_path = "M99.6960486322188,0 L299.088145896657,0 400,209.1 0,209.1 99.6960486322188,0 Z"
shapes["trapezium.svg"] = wrap_svg(f'<path d="{trapez_path}" fill="currentColor" transform="translate(0,95.45)"/>' )

ring_path = ("M198.857142857143,0 C308.571428571429,0 400,89.1428571428571 400,198.857142857143 "
             "400,308.571428571429 308.571428571429,400 198.857142857143,400 89.1428571428571,400 "
             "0,308.571428571429 0,198.857142857143 0,89.1428571428571 89.1428571428571,0 198.857142857143,0 Z "
             "M198.857142857143,132.571428571429 C235.428571428571,132.571428571429 265.142857142857,162.285714285714 "
             "265.142857142857,198.857142857143 265.142857142857,235.428571428571 235.428571428571,265.142857142857 "
             "198.857142857143,265.142857142857 162.285714285714,265.142857142857 132.571428571429,235.428571428571 "
             "132.571428571429,198.857142857143 132.571428571429,162.285714285714 162.285714285714,132.571428571429 "
             "198.857142857143,132.571428571429 Z")
shapes["ring.svg"] = wrap_svg(f'<path d="{ring_path}" fill="currentColor" fill-rule="evenodd" />')

half_circle_path = "M200,0 C310.112359550562,0 400,89.8876404494382 400,200 L0,200 C0,89.8876404494382 89.8876404494382,0 200,0 Z"
shapes["half_circle.svg"] = wrap_svg(f'<path d="{half_circle_path}" fill="currentColor" transform="translate(0,100)"/>' )

right_tri_path = "M0,0 L400,0 198.895027624309,198.9 0,0 Z"
shapes["rightangled_triangle.svg"] = wrap_svg(f'<path d="{right_tri_path}" fill="currentColor" transform="translate(0,100)"/>' )

arrow_path = "M0,254.325 L200,254.325 200,339.1 400,169.55 200,0 200,84.775 0,84.775 0,254.325 Z"
shapes["arrow.svg"] = wrap_svg(f'<path d="{arrow_path}" fill="currentColor" transform="translate(0,30.45)"/>' )

shapes["ellipse.svg"] = wrap_svg('<ellipse cx="200" cy="200" rx="116.35" ry="200" fill="currentColor" />')

heart_path = ("M400,99.9929085944319 C400,44.7683700799265 355.22873313053,0 300.000621247921,0 "
              "244.77126686947,0 200,44.7683700799265 200,99.9929085944319 "
              "200,44.7683700799265 155.22873313053,0 100.000621247921,0 "
              "44.7712668694696,0 0,44.7683700799265 0,99.9929085944319 "
              "0,224.656874935408 200,332.6 200,332.6 200,332.6 400,224.656874935408 400,99.9929085944319 Z")
shapes["heart.svg"] = wrap_svg(f'<path d="{heart_path}" fill="currentColor" transform="translate(0,33.7)"/>' )

parallelogram_path = "M92.4791086350975,0 L400,0 306.406685236769,215 0,215 92.4791086350975,0 Z"
shapes["parallelogram.svg"] = wrap_svg(f'<path d="{parallelogram_path}" fill="currentColor" transform="translate(0,92.5)"/>' )

flag_path = "M0,0 L400,0 400,400 0,400 142,200 0,0 Z"
shapes["flag.svg"] = wrap_svg(f'<path d="{flag_path}" fill="currentColor" />')

cross_lines = wrap_svg(
    '<line x1="80" y1="0" x2="80" y2="160" stroke="currentColor" stroke-width="10" />\n'
    '<line x1="0" y1="80" x2="160" y2="80" stroke="currentColor" stroke-width="10" />',
    viewBox="0 0 160 160"
)
shapes["cross_lines.svg"] = cross_lines

for fname, svg in shapes.items():
    with open(os.path.join(out_dir, fname), "w", encoding="utf-8") as f:
        f.write(svg)

# Centering helpers
def parse_transform_list(transform_str):
    items = []
    if not transform_str:
        return items
    for kind, args in re.findall(r'(translate|scale)\s*\(([^)]*)\)', transform_str):
        nums = [float(x) for x in re.split(r'[,\s]+', args.strip()) if x]
        if kind == 'translate':
            tx = nums[0] if nums else 0.0
            ty = nums[1] if len(nums) > 1 else 0.0
            items.append(('translate', (tx, ty)))
        elif kind == 'scale':
            sx = nums[0] if nums else 1.0
            sy = nums[1] if len(nums) > 1 else sx
            items.append(('scale', (sx, sy)))
    return items

def apply_transforms(x, y, transforms):
    for kind, vals in transforms:
        if kind == 'translate':
            tx, ty = vals
            x += tx; y += ty
        elif kind == 'scale':
            sx, sy = vals
            x *= sx; y *= sy
    return x, y

def bbox_union(b1, b2):
    if b1 is None: return b2
    if b2 is None: return b1
    (minx1, miny1, maxx1, maxy1) = b1
    (minx2, miny2, maxx2, maxy2) = b2
    return (min(minx1, minx2), min(miny1, miny2), max(maxx1, maxx2), max(maxy1, maxy2))

def parse_attrs(tag):
    return dict(re.findall(r'(\w+)=["\']([^"\']+)["\']', tag))

def bbox_from_path(d, transform_attr):
    nums = [float(n) for n in re.findall(r'[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?', d)]
    if not nums:
        return None
    pairs = list(zip(nums[0::2], nums[1::2]))
    transforms = parse_transform_list(transform_attr)
    xs, ys = [], []
    for x, y in pairs:
        x2, y2 = apply_transforms(x, y, transforms)
        xs.append(x2); ys.append(y2)
    return (min(xs), min(ys), max(xs), max(ys))

def bbox_from_rect(attrs, transform_attr):
    x = float(attrs.get('x', 0)); y = float(attrs.get('y', 0))
    w = float(attrs.get('width', 0)); h = float(attrs.get('height', 0))
    transforms = parse_transform_list(transform_attr)
    pts = [(x,y), (x+w,y), (x,y+h), (x+w,y+h)]
    xs, ys = [], []
    for px, py in pts:
        px2, py2 = apply_transforms(px, py, transforms)
        xs.append(px2); ys.append(py2)
    return (min(xs), min(ys), max(xs), max(ys))

def bbox_from_circle(attrs, transform_attr):
    cx = float(attrs.get('cx', 0)); cy = float(attrs.get('cy', 0)); r = float(attrs.get('r', 0))
    transforms = parse_transform_list(transform_attr)
    p1 = apply_transforms(cx - r, cy - r, transforms)
    p2 = apply_transforms(cx + r, cy + r, transforms)
    return (min(p1[0], p2[0]), min(p1[1], p2[1]), max(p1[0], p2[0]), max(p1[1], p2[1]))

def bbox_from_ellipse(attrs, transform_attr):
    cx = float(attrs.get('cx', 0)); cy = float(attrs.get('cy', 0))
    rx = float(attrs.get('rx', 0)); ry = float(attrs.get('ry', 0))
    transforms = parse_transform_list(transform_attr)
    p1 = apply_transforms(cx - rx, cy - ry, transforms)
    p2 = apply_transforms(cx + rx, cy + ry, transforms)
    return (min(p1[0], p2[0]), min(p1[1], p2[1]), max(p1[0], p2[0]), max(p1[1], p2[1]))

def bbox_from_line(attrs, transform_attr):
    x1 = float(attrs.get('x1', 0)); y1 = float(attrs.get('y1', 0))
    x2 = float(attrs.get('x2', 0)); y2 = float(attrs.get('y2', 0))
    transforms = parse_transform_list(transform_attr)
    X1,Y1 = apply_transforms(x1,y1,transforms)
    X2,Y2 = apply_transforms(x2,y2,transforms)
    return (min(X1,X2), min(Y1,Y2), max(X1,X2), max(Y1,Y2))

def center_to_400(svg):
    svg = svg.replace('fill="currentColor"', 'fill="#000000"').replace('stroke="currentColor"', 'stroke="#000000"') # currentColor = black
    m_header = re.search(r'<svg[^>]*viewBox="([^"]+)"[^>]*>', svg)
    if not m_header:
        return svg
    viewBox = m_header.group(1)
    vb_nums = [float(x) for x in viewBox.split()]
    if len(vb_nums) != 4: vb_nums = [0,0,400,400]
    vb_x, vb_y, vb_w, vb_h = vb_nums

    inner = re.search(r'<svg[^>]*>(.*)</svg>', svg, re.DOTALL)
    content = inner.group(1) if inner else svg

    bbox = None
    for m in re.finditer(r'<path\s+[^>]*>', content):
        attrs = parse_attrs(m.group(0))
        b = bbox_from_path(attrs.get('d',''), attrs.get('transform',''))
        if b: bbox = bbox_union(bbox, b)
    for m in re.finditer(r'<rect\s+[^>]*>', content):
        attrs = parse_attrs(m.group(0))
        b = bbox_from_rect(attrs, attrs.get('transform',''))
        if b: bbox = bbox_union(bbox, b)
    for m in re.finditer(r'<circle\s+[^>]*>', content):
        attrs = parse_attrs(m.group(0))
        b = bbox_from_circle(attrs, attrs.get('transform',''))
        if b: bbox = bbox_union(bbox, b)
    for m in re.finditer(r'<ellipse\s+[^>]*>', content):
        attrs = parse_attrs(m.group(0))
        b = bbox_from_ellipse(attrs, attrs.get('transform',''))
        if b: bbox = bbox_union(bbox, b)
    for m in re.finditer(r'<line\s+[^>]*>', content):
        attrs = parse_attrs(m.group(0))
        b = bbox_from_line(attrs, attrs.get('transform',''))
        if b: bbox = bbox_union(bbox, b)

    if bbox is None:
        return svg

    minx, miny, maxx, maxy = bbox
    width = maxx - minx
    height = maxy - miny

    # Upscale 160×160 cross into 400×400 - optional
    if int(vb_w) == 160 and int(vb_h) == 160:
        scale = 400.0/160.0
        tx = (400 - width*scale)/2 - minx*scale
        ty = (400 - height*scale)/2 - miny*scale
        svg = re.sub(r'viewBox="[^"]+"', 'viewBox="0 0 400 400"', svg)
        svg = re.sub(r'(<svg[^>]*>)', r'\1' + f'\n  <g transform="translate({tx:.6f},{ty:.6f}) scale({scale:.6f})">', svg, count=1)
        svg = svg.replace('</svg>', '</g>\n</svg>')
        return svg

    tx = (vb_w - width)/2 - minx + vb_x
    ty = (vb_h - height)/2 - miny + vb_y
    svg = re.sub(r'(<svg[^>]*>)', r'\1' + f'\n  <g transform="translate({tx:.6f},{ty:.6f})">', svg, count=1)
    svg = svg.replace('</svg>', '</g>\n</svg>')
    return svg

# Center all and make black
for fname in sorted(os.listdir(out_dir)):
    if not fname.endswith(".svg"): continue
    p = os.path.join(out_dir, fname)
    with open(p, "r", encoding="utf-8") as f:
        s = f.read()
    s2 = center_to_400(s)
    with open(p, "w", encoding="utf-8") as f:
        f.write(s2)

# README
readme = """# Simple Figures — Centered SVG Set (Black on Transparent)

Converted from XAML to SVG. Each file:
- viewBox: **400×400** (the thin stroked cross is upscaled to this size)
- background: **transparent**
- color: **black** (`#000`)
- geometry: **centered**

See `index.html` for quick preview.
"""

with open(os.path.join(out_dir, "README.md"), "w", encoding="utf-8") as f:
    f.write(readme)

# HTML index
index_path = os.path.join(out_dir, "index.html")
items = []
for fname in sorted(os.listdir(out_dir)):
    if fname.endswith(".svg"):
        items.append(f'<li><a href="{fname}">{fname}</a></li>') # assuming the HTML is in the same folder where the SVGs are
html = f"""<!doctype html>
<html><head><meta charset="utf-8"><title>SVG Index</title></head>
<body><h1>SVG Index (Black, Centered)</h1><ul>{''.join(items)}</ul></body></html>
"""
with open(index_path, "w", encoding="utf-8") as f:
    f.write(html)

# Zip
zip_path = "xaml_to_svg_shapes_black_centered.zip"
with zipfile.ZipFile(zip_path, "w", compression=zipfile.ZIP_DEFLATED) as zf:
    for fname in sorted(os.listdir(out_dir)):
        zf.write(os.path.join(out_dir, fname), arcname=fname)

zip_path, index_path, sorted([f for f in os.listdir(out_dir) if f.endswith(".svg")])